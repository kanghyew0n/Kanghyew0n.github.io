<br/>

# [JavaScript] 타입 2

<br/>

## 원시 자료형과 참조 자료형 

* 원시 자료형 (primitive data types) : `Number` , `String` , `boolean` , `null`, `undefined`, `bigint` , `symbol` 
*  참조 자료형 (reference data type) : `array` , `object` , `function` (대표적)

<br/>


## 원시 자료형 

원시 자료형이라고 부르는 이유는 **'하나'의 정보**, 즉 데이터를 담고있기 때문이다. 원시 자료형의 데이터가 보관된 보관함은 모두 같은 크기를 가지고있고 이를 `stack`이라고 부른다.

* 하나의 변수엔 **하나의 데이터 **
* 값 자체에 대한 변경은 불가능함 (**immutable**)
* **재할당은 가능**

```js
let x = 2;
let y = x; // x값을 복사하여 y에 저장함 현재 y의 값은 2
y = 3; // y의 값을 재할당함 따라서 y의 값은 3이 되고 x의 값은 변화없음 
```

```js
let x = 2;
let y = x; // x값을 복사하여 y에 저장함, y의 값은 2
x = 3; // x 자체에 재할당 해줘야 함, x 값은 3
```

<br/>


## 참조 자료형 

원시 자료형이 아닌 것은 모두 참조 자료형이다. 원시 자료형과 반대로 하나의 데이터가 아닌 **여러 데이터**가 담기게 된다. 그래서 원시 자료형이 보관되는 변수에는 주소를 담고 주소를 따라가면 참조 자료형 데이터를 담고있는 보관함이 있다. 이는 사이즈가 동적으로 변하고 이 데이터 보관함을 `heap`이라고 한다. 

* 원시 자료형이 아닌 모든 것
*  변수에는 주소를 저장하고  `heap` 이라는 보관함에 데이터를 저장함 
* 참조 자료형이 변수에 할당되는 경우는, **변수에 이 데이터가 저장되는 곳의 주소** 할당됨 
* `heap` 안에 저장된 데이터는 **사이즈를 동적**으로 조정할 수 있음 
* 주소값을 복사해도 복사한 곳에서 데이터를 변경하면 원본도 변경됨 (같은 주소라서)

```js
let x = { foo: 3 };
let y = x; // x의 주소를 y에 할당함 
y.foo = 2; // x와 y의 주소가 같기 때문에 y에서 수정을 해도 x.foo도 2가 됨 
```

```js
console.log([1,2,3] === [1,2,3]);
console.log({ foo: 'bar' } === { foo: 'bar' });
```

* 위의 코드에서 `[1,2,3] === [1,2,3]` 는 값이 같아보이지만 다른 주소를 가지고 있음 (다른 저장공간) 따라서 `flase` 임 


<br/>
<br/>


